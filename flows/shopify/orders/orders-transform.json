{
  "name": "Orders Transform",
  "description": "Transforms raw Shopify orders into normalized format for the orders and order_lines tables",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": "{{ $vars.TRANSFORM_INTERVAL_MINUTES || 5 }}"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "{{ $vars.SUPABASE_HOST + '/rest/v1/raw_shopify_orders' }}",
        "method": "GET",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "{{ $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "{{ 'Bearer ' + $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {
          "qs": {
            "select": "*",
            "limit": "{{ $vars.TRANSFORM_BATCH_SIZE || 100 }}",
            "order": "created_at.desc",
            "processed": "eq.false"
          }
        }
      },
      "id": "fetch-raw-orders",
      "name": "Fetch Unprocessed Raw Orders",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [460, 300]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced data processing with validation and error handling\nfunction processOrder(order) {\n  try {\n    // Validate required fields\n    if (!order.id) {\n      throw new Error('Missing required field: id');\n    }\n\n    return {\n      shopify_order_id: order.id,\n      order_number: order.order_number?.toString() || '',\n      order_name: order.name || '',\n      customer_email: order.email || '',\n      customer_first_name: order.customer?.first_name || '',\n      customer_last_name: order.customer?.last_name || '',\n      total_price: parseFloat(order.total_price) || 0,\n      subtotal_price: parseFloat(order.subtotal_price) || 0,\n      total_tax: parseFloat(order.total_tax) || 0,\n      total_shipping: parseFloat(order.total_shipping_price_set?.shop_money?.amount) || 0,\n      total_discount: parseFloat(order.total_discounts) || 0,\n      currency: order.currency || 'USD',\n      financial_status: order.financial_status || '',\n      fulfillment_status: order.fulfillment_status || '',\n      created_at: order.created_at,\n      updated_at: order.updated_at,\n      processed_at: order.processed_at,\n      fulfilled_at: order.fulfilled_at,\n      cancelled_at: order.cancelled_at,\n      closed_at: order.closed_at,\n      shipping_address: order.shipping_address || {},\n      billing_address: order.billing_address || {},\n      tags: order.tags ? order.tags.split(',').map(t => t.trim()).filter(t => t) : [],\n      note: order.note || '',\n      phone: order.phone || '',\n      browser_ip: order.browser_ip || '',\n      landing_site: order.landing_site || '',\n      referring_site: order.referring_site || '',\n      source_name: order.source_name || '',\n      raw_shopify_data: order\n    };\n  } catch (error) {\n    console.error('Error processing order:', error.message, 'Order ID:', order.id);\n    return null;\n  }\n}\n\nfunction processLineItem(orderId, line) {\n  try {\n    if (!line.id) {\n      throw new Error('Missing required field: line item id');\n    }\n\n    return {\n      shopify_order_id: orderId,\n      shopify_line_item_id: line.id,\n      product_id: line.product_id,\n      variant_id: line.variant_id,\n      title: line.title || line.name || '',\n      variant_title: line.variant_title || '',\n      sku: line.sku || '',\n      vendor: line.vendor || '',\n      quantity: parseInt(line.quantity) || 0,\n      price: parseFloat(line.price) || 0,\n      original_price: parseFloat(line.original_price) || 0,\n      total_discount: parseFloat(line.total_discount) || 0,\n      fulfillment_status: line.fulfillment_status || '',\n      fulfillable_quantity: parseInt(line.fulfillable_quantity) || 0,\n      requires_shipping: typeof line.requires_shipping === 'boolean' ? line.requires_shipping : null,\n      taxable: typeof line.taxable === 'boolean' ? line.taxable : null,\n      gift_card: typeof line.gift_card === 'boolean' ? line.gift_card : false,\n      product_exists: typeof line.product_exists === 'boolean' ? line.product_exists : null,\n      raw_line_item_data: line\n    };\n  } catch (error) {\n    console.error('Error processing line item:', error.message, 'Line Item ID:', line.id);\n    return null;\n  }\n}\n\nconst orders = [];\nconst orderLines = [];\nconst errors = [];\nconst processedIds = [];\n\n// Get all input items\nconst items = $input.all();\n\nconsole.log(`Starting transformation of ${items.length} raw order records`);\n\nfor (const item of items) {\n  const orderData = item.json;\n  \n  try {\n    const processedOrder = processOrder(orderData);\n    if (processedOrder) {\n      orders.push(processedOrder);\n      processedIds.push(orderData.id);\n      \n      if (orderData.line_items && Array.isArray(orderData.line_items)) {\n        orderData.line_items.forEach(line => {\n          const processedLine = processLineItem(orderData.id, line);\n          if (processedLine) {\n            orderLines.push(processedLine);\n          } else {\n            errors.push(`Failed to process line item ${line.id} for order ${orderData.id}`);\n          }\n        });\n      }\n    } else {\n      errors.push(`Failed to process order ${orderData.id}`);\n    }\n  } catch (error) {\n    errors.push(`Unexpected error processing order ${orderData.id}: ${error.message}`);\n  }\n}\n\n// Add detailed logging\nconsole.log('=== ORDER TRANSFORMATION LOG ===');\nconsole.log('Input records:', items.length);\nconsole.log('Successfully processed orders:', orders.length);\nconsole.log('Total order lines:', orderLines.length);\nconsole.log('Processing errors:', errors.length);\nif (orders.length > 0) {\n  console.log('Sample order:', {\n    id: orders[0].shopify_order_id,\n    number: orders[0].order_number,\n    total: orders[0].total_price\n  });\n}\nif (errors.length > 0) {\n  console.log('Errors:', errors.slice(0, 10)); // Show first 10 errors\n}\nconsole.log('===============================');\n\nconst result = {\n  transform_type: 'orders',\n  source: 'raw_shopify_orders',\n  input_records: items.length,\n  orders_processed: orders.length,\n  order_lines_processed: orderLines.length,\n  errors_count: errors.length,\n  errors: errors.slice(0, 50), // Limit error details\n  processed_ids: processedIds,\n  transform_timestamp: $now.toISOString(),\n  status: errors.length === 0 ? 'success' : 'partial'\n};\n\nreturn [\n  { json: { type: 'orders', data: orders } },\n  { json: { type: 'order_lines', data: orderLines } },\n  { json: { type: 'transform_summary', data: result } }\n];"
      },
      "id": "transform-data",
      "name": "Transform & Validate Orders",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [680, 300]
    },
    {
      "parameters": {
        "url": "{{ $vars.SUPABASE_HOST + '/rest/v1/orders?on_conflict=shopify_order_id' }}",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "{{ $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "{{ 'Bearer ' + $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates,return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.data }}",
        "options": {
          "retry": {
            "enabled": true,
            "maxAttempts": 3,
            "waitBetween": 2000
          }
        }
      },
      "id": "upsert-orders",
      "name": "Upsert Normalized Orders",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [900, 200],
      "continueOnFail": true
    },
    {
      "parameters": {
        "url": "{{ $vars.SUPABASE_HOST + '/rest/v1/order_lines?on_conflict=shopify_line_item_id' }}",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "{{ $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "{{ 'Bearer ' + $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "resolution=merge-duplicates,return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.data }}",
        "options": {
          "retry": {
            "enabled": true,
            "maxAttempts": 3,
            "waitBetween": 2000
          }
        }
      },
      "id": "upsert-order-lines",
      "name": "Upsert Normalized Order Lines",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [900, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "passThrough",
        "output": "input1"
      },
      "id": "merge-results",
      "name": "Merge Results",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "url": "{{ $vars.SUPABASE_HOST + '/rest/v1/raw_shopify_orders' }}",
        "method": "PATCH",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "{{ $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Authorization",
              "value": "{{ 'Bearer ' + $vars.SUPABASE_SERVICE_ROLE_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=representation"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"processed\": true,\n  \"processed_at\": \"{{ $now.toISOString() }}\"\n}",
        "options": {
          "qs": {
            "id": "in.({{ $json.data.processed_ids.join(',') }})"
          }
        }
      },
      "id": "mark-processed",
      "name": "Mark Raw Orders as Processed",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1340, 300],
      "continueOnFail": true
    },
    {
      "parameters": {
        "functionCode": "// Final logging for monitoring\nconst summary = $input.first().json.data;\n\nconsole.log('=== ORDERS TRANSFORM COMPLETE ===');\nconsole.log('Transform timestamp:', $now.toISOString());\nconsole.log('Records processed:', summary.input_records);\nconsole.log('Orders upserted:', summary.orders_processed);\nconsole.log('Order lines upserted:', summary.order_lines_processed);\nconsole.log('Errors:', summary.errors_count);\nconsole.log('Status:', summary.status);\nconsole.log('===============================');\n\nreturn [{ json: summary }];"
      },
      "id": "final-log",
      "name": "Final Logging",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1560, 300]
    }
  ],
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Fetch Unprocessed Raw Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Unprocessed Raw Orders": {
      "main": [
        [
          {
            "node": "Transform & Validate Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform & Validate Orders": {
      "main": [
        [
          {
            "node": "Upsert Normalized Orders",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upsert Normalized Order Lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Normalized Orders": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert Normalized Order Lines": {
      "main": [
        [
          {
            "node": "Merge Results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Results": {
      "main": [
        [
          {
            "node": "Mark Raw Orders as Processed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark Raw Orders as Processed": {
      "main": [
        [
          {
            "node": "Final Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "activeCount": 0
}